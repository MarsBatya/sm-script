#!/usr/bin/env bash

# Service Manager (sm) - A lightweight wrapper around systemctl and journalctl
# Usage: sm <command> [args]

set -e

# Configuration
SM_DIR="$HOME/.sm"
SM_PROJECTS_FILE="$SM_DIR/projects.txt"
SERVICE_TEMPLATE="$SM_DIR/service.template"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Initialize sm directory and files
init_sm() {
    if [[ ! -d "$SM_DIR" ]]; then
        mkdir -p "$SM_DIR"
    fi
    
    if [[ ! -f "$SM_PROJECTS_FILE" ]]; then
        touch "$SM_PROJECTS_FILE"
    fi
    
    if [[ ! -f "$SERVICE_TEMPLATE" ]]; then
        cat > "$SERVICE_TEMPLATE" << 'EOF'
[Unit]
Description={{DESCRIPTION}}
After=network.target

[Service]
Type=simple
Restart=always
RestartSec=10
User={{USER}}
WorkingDirectory={{WORKING_DIR}}
ExecStart={{EXEC_START}}
MemoryMax=1G
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF
    fi
}

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if project exists in our registry
project_exists() {
    local name="$1"
    grep -q "^$name:" "$SM_PROJECTS_FILE" 2>/dev/null
}

# Add project to registry
add_to_registry() {
    local name="$1"
    local service_file="$2"
    local working_dir="$3"
    echo "$name:$service_file:$working_dir" >> "$SM_PROJECTS_FILE"
}

# Get service file path for project
get_service_file() {
    local name="$1"
    grep "^$name:" "$SM_PROJECTS_FILE" 2>/dev/null | cut -d: -f2
}

# Remove project from registry
remove_from_registry() {
    local name="$1"
    if [[ -f "$SM_PROJECTS_FILE" ]]; then
        sed -i "/^$name:/d" "$SM_PROJECTS_FILE"
    fi
}

# Infer project name from .service file in current directory
infer_project_name() {
    local current_dir=$(pwd)
    local service_files=(*.service)
    
    # Check if any .service files exist
    if [[ ${#service_files[@]} -eq 1 && "${service_files[0]}" == "*.service" ]]; then
        return 1  # No service files found
    fi
    
    if [[ ${#service_files[@]} -eq 1 ]]; then
        # Single service file found
        local service_file="${service_files[0]}"
        local name=$(basename "$service_file" .service)
        echo "$name"
        return 0
    else
        # Multiple service files found
        log_warning "Multiple .service files found in current directory:"
        for i in "${!service_files[@]}"; do
            echo "  $((i+1))) ${service_files[$i]}"
        done
        read -p "Select service file (1-${#service_files[@]}): " choice
        
        if [[ "$choice" -ge 1 && "$choice" -le ${#service_files[@]} ]]; then
            local service_file="${service_files[$((choice-1))]}"
            local name=$(basename "$service_file" .service)
            echo "$name"
            return 0
        else
            log_error "Invalid selection"
            return 1
        fi
    fi
}

# Generate service file from template
generate_service() {
    local name="$1"
    local description="$2"
    local exec_start="$3"
    local working_dir="$4"
    local user="$5"
    local service_file="$working_dir/$name.service"
    
    sed -e "s|{{DESCRIPTION}}|$description|g" \
        -e "s|{{USER}}|$user|g" \
        -e "s|{{WORKING_DIR}}|$working_dir|g" \
        -e "s|{{EXEC_START}}|$exec_start|g" \
        "$SERVICE_TEMPLATE" > "$service_file"
    
    echo "$service_file"
}

# Find the directory containing the sm script
find_sm_repo() {
    # Get the actual path of the sm script (resolving symlinks)
    local sm_script_path
    sm_script_path=$(readlink -f "$(command -v sm)")
    
    if [[ -z "$sm_script_path" ]]; then
        return 1
    fi
    
    # Get the directory containing the script
    dirname "$sm_script_path"
}

# Command implementations
cmd_add() {
    local current_dir=$(pwd)
    local service_files=(*.service)
    
    # Check if any .service files exist
    if [[ ${#service_files[@]} -eq 1 && "${service_files[0]}" == "*.service" ]]; then
        log_info "No .service file found in current directory."
        echo
        read -p "Generate a new service file? (y/N): " generate
        
        if [[ "$generate" =~ ^[Yy]$ ]]; then
            echo
            read -p "Project name: " name
            [[ -z "$name" ]] && { log_error "Project name is required"; exit 1; }
            
            read -p "Description: " description
            [[ -z "$description" ]] && description="$name service"
            
            read -p "Command to start the service (e.g., 'path/to/python main.py', './myapp', etc.): " exec_command
            [[ -z "$exec_command" ]] && { log_error "Start command is required"; exit 1; }

            # Parse the command to extract the executable and arguments
            read -a cmd_array <<< "$exec_command"
            executable="${cmd_array[0]}"
            args="${cmd_array[@]:1}"

            # Handle different types of executables
            if [[ "$executable" =~ ^/ ]]; then
                # Already absolute path
                abs_executable="$executable"
            elif command -v "$executable" >/dev/null 2>&1; then
                # It's a system command (like python, node, java, etc.)
                abs_executable="$(command -v "$executable")"
                log_info "Using system executable: $abs_executable"
            else
                # Relative path - make it absolute
                abs_executable="$current_dir/$executable"
            fi

            # Validate the executable
            if command -v "$executable" >/dev/null 2>&1; then
                # System command exists
                log_info "System command '$executable' found"
            elif [[ -f "$abs_executable" && -x "$abs_executable" ]]; then
                # Local executable exists and is executable
                log_info "Local executable '$abs_executable' found"
            elif [[ -f "$abs_executable" ]]; then
                # File exists but not executable
                log_warning "File '$abs_executable' exists but is not executable. You may need to run: chmod +x '$abs_executable'"
            else
                # File doesn't exist
                log_warning "Executable '$executable' not found in PATH or at '$abs_executable'"
            fi

            # For relative paths in the final command, we might want to use absolute paths
            if [[ "$executable" =~ ^/ ]] || command -v "$executable" >/dev/null 2>&1; then
                # Use the command as-is (absolute path or system command)
                final_exec_start="$exec_command"
            else
                # Convert relative executable to absolute path
                final_exec_start="$abs_executable $args"
            fi

            log_info "ExecStart will be set to: $final_exec_start"

            local user=$(whoami)
            local service_file=$(generate_service "$name" "$description" "$final_exec_start" "$current_dir" "$user")
            
            log_success "Generated service file: $service_file"
            
            # Install the service
            sudo cp "$service_file" "/etc/systemd/system/"
            sudo systemctl daemon-reload
            
            add_to_registry "$name" "$service_file" "$current_dir"
            log_success "Project '$name' added successfully, to start it, use 'sm start $name'"
        fi
    else
        # Use existing service file
        if [[ ${#service_files[@]} -eq 1 ]]; then
            local service_file="${service_files[0]}"
        else
            echo "Multiple .service files found:"
            for i in "${!service_files[@]}"; do
                echo "  $((i+1))) ${service_files[$i]}"
            done
            read -p "Select service file (1-${#service_files[@]}): " choice
            service_file="${service_files[$((choice-1))]}"
        fi
        
        local name=$(basename "$service_file" .service)
        
        if project_exists "$name"; then
            log_error "Project '$name' already exists"
            exit 1
        fi
        
        # Check if service already exists in systemd
        if [[ -f "/etc/systemd/system/$name.service" ]]; then
            log_warning "Service '$name.service' already exists in systemd"
            echo
            echo "Options:"
            echo "  1) Add to sm management only (recommended if service is already working)"
            echo "  2) Overwrite systemd service file and reload"
            echo "  3) Cancel"
            echo
            read -p "Choose option (1-3): " choice
            
            case "$choice" in
                1)
                    # Just add to registry without touching systemd
                    add_to_registry "$name" "$current_dir/$service_file" "$current_dir"
                    log_success "Project '$name' added to sm management"
                    ;;
                2)
                    # Overwrite and reload
                    log_info "Overwriting existing service file..."
                    sudo cp "$service_file" "/etc/systemd/system/"
                    sudo systemctl daemon-reload
                    add_to_registry "$name" "$current_dir/$service_file" "$current_dir"
                    log_success "Project '$name' added and service file updated"
                    ;;
                3)
                    log_info "Operation cancelled"
                    exit 0
                    ;;
                *)
                    log_error "Invalid option"
                    exit 1
                    ;;
            esac
        else
            # Service doesn't exist, install normally
            sudo cp "$service_file" "/etc/systemd/system/"
            sudo systemctl daemon-reload
            add_to_registry "$name" "$current_dir/$service_file" "$current_dir"
            log_success "Project '$name' added successfully, to start it, use 'sm start $name'"
        fi
    fi
}

cmd_start() {
    local name="$1"
    
    # If no name provided, try to infer from current directory
    if [[ -z "$name" ]]; then
        name=$(infer_project_name)
        if [[ $? -ne 0 || -z "$name" ]]; then
            log_error "No project name provided and no .service file found in current directory"
            log_info "Usage: sm start <project_name> or run from directory containing .service file"
            exit 1
        fi
        log_info "Inferred project name: $name"
    fi
    
    if ! project_exists "$name"; then
        log_error "Project '$name' not found. Use 'sm ls' to see available projects or 'sm add' to add it."
        exit 1
    fi
    
    log_info "Starting service '$name'..."
    sudo systemctl enable "$name.service"
    sudo systemctl restart "$name.service"
    
    # Check if service started successfully
    if systemctl is-active --quiet "$name.service"; then
        log_success "Service '$name' started successfully"
    else
        log_error "Failed to start service '$name'"
        echo "Use 'sm logs $name' to see error details"
        exit 1
    fi
}

cmd_stop() {
    local name="$1"
    
    # If no name provided, try to infer from current directory
    if [[ -z "$name" ]]; then
        name=$(infer_project_name)
        if [[ $? -ne 0 || -z "$name" ]]; then
            log_error "No project name provided and no .service file found in current directory"
            log_info "Usage: sm stop <project_name> or run from directory containing .service file"
            exit 1
        fi
        log_info "Inferred project name: $name"
    fi
    
    if ! project_exists "$name"; then
        log_error "Project '$name' not found. Use 'sm ls' to see available projects."
        exit 1
    fi
    
    log_info "Stopping service '$name'..."
    sudo systemctl stop "$name.service"
    log_success "Service '$name' stopped"
}

cmd_logs() {
    local name="$1"
    
    # If no name provided, try to infer from current directory
    if [[ -z "$name" ]]; then
        name=$(infer_project_name)
        if [[ $? -ne 0 || -z "$name" ]]; then
            log_error "No project name provided and no .service file found in current directory"
            log_info "Usage: sm start <project_name> or run from directory containing .service file"
            exit 1
        fi
        log_info "Inferred project name: $name"
    fi

    if ! project_exists "$name"; then
        log_error "Project '$name' not found. Use 'sm ls' to see available projects."
        exit 1
    fi
    
    log_info "Showing logs for '$name' (press Ctrl+C to exit)..."
    echo
    
    # Set up signal handling to exit cleanly
    trap 'echo; log_info "Stopped watching logs"; exit 0' INT TERM
    
    # Execute journalctl in a way that handles interruption better
    exec journalctl -u "$name.service" -f --no-pager
}

cmd_workdir() {
    local name="$1"
    
    if [[ -z "$name" ]]; then
        exit 1
    fi
    
    if ! project_exists "$name"; then
        exit 1
    fi
    
    while IFS=':' read -r proj_name service_file working_dir; do
        if [[ "$proj_name" == "$name" ]]; then
            echo "$working_dir"
            exit 0
        fi
    done < "$SM_PROJECTS_FILE"
    
    exit 1
}


# Helper function to format uptime
format_uptime() {
    local uptime_str="$1"
    if [[ -z "$uptime_str" || "$uptime_str" == "n/a" ]]; then
        echo "-"
        return
    fi
    
    local start_epoch=$(date -d "$uptime_str" +%s 2>/dev/null)
    if [[ $? -ne 0 ]]; then
        echo "-"
        return
    fi
    
    local current_epoch=$(date +%s)
    local diff=$((current_epoch - start_epoch))
    
    if [[ $diff -lt 60 ]]; then
        echo "${diff}s"
    elif [[ $diff -lt 3600 ]]; then
        echo "$((diff/60))m"
    elif [[ $diff -lt 86400 ]]; then
        echo "$((diff/3600))h$((diff%3600/60))m"
    else
        echo "$((diff/86400))d$((diff%86400/3600))h"
    fi
}

cmd_ls() {
    if [[ ! -s "$SM_PROJECTS_FILE" ]]; then
        log_info "No projects found. Use 'sm add' to add a project."
        return
    fi
    
    echo
    printf "%-20s %-10s %-8s %-10s %-12s %-30s\n" "NAME" "STATUS" "PID" "MEMORY" "UPTIME" "WORKING DIRECTORY"
    printf "%-20s %-10s %-8s %-10s %-12s %-30s\n" "----" "------" "---" "------" "------" "-----------------"
    
    # Read all project names first
    local -a project_names=()
    local -A project_data=()
    
    while IFS=':' read -r name service_file working_dir; do
        project_names+=("$name")
        project_data["$name"]="$service_file:$working_dir"
    done < "$SM_PROJECTS_FILE"
    
    # Batch systemctl calls for better performance
    local -A service_status=()
    local -A service_pids=()
    local -A service_uptimes=()
    
    # Get all statuses in one call
    if [[ ${#project_names[@]} -gt 0 ]]; then
        local services=()
        for name in "${project_names[@]}"; do
            services+=("$name.service")
        done
        
        # Batch status check
        while read -r service status; do
            local name="${service%.service}"
            service_status["$name"]="$status"
        done < <(systemctl is-active "${services[@]}" 2>/dev/null | nl -nln -w1 -s' ' | while read -r i status; do
            echo "${services[$((i-1))]} $status"
        done)
        
        # Get running services for PID and uptime batch queries
        local -a running_services=()
        for name in "${project_names[@]}"; do
            if [[ "${service_status[$name]}" == "active" ]]; then
                running_services+=("$name.service")
            fi
        done
        
        # Batch PID retrieval for running services
        if [[ ${#running_services[@]} -gt 0 ]]; then
            while read -r service pid; do
                local name="${service%.service}"
                [[ "$pid" == "0" ]] && pid="-"
                service_pids["$name"]="$pid"
            done < <(systemctl show -p MainPID "${running_services[@]}" 2>/dev/null | \
                    grep -E '^MainPID=' | \
                    paste <(printf '%s\n' "${running_services[@]}") - | \
                    sed 's/MainPID=//')
            
            # Batch uptime retrieval for running services
            while read -r service timestamp; do
                local name="${service%.service}"
                service_uptimes["$name"]="$timestamp"
            done < <(systemctl show -p ActiveEnterTimestamp "${running_services[@]}" 2>/dev/null | \
                    grep -E '^ActiveEnterTimestamp=' | \
                    paste <(printf '%s\n' "${running_services[@]}") - | \
                    sed 's/ActiveEnterTimestamp=//')
        fi
    fi
    
    # Get memory info for all PIDs in one ps call
    local -A pid_memory=()
    local -a all_pids=()
    for name in "${project_names[@]}"; do
        local pid="${service_pids[$name]}"
        if [[ -n "$pid" && "$pid" != "-" ]]; then
            all_pids+=("$pid")
        fi
    done
    
    if [[ ${#all_pids[@]} -gt 0 ]]; then
        while read -r pid rss; do
            pid_memory["$pid"]=$(awk "BEGIN {printf \"%.1fM\", $rss/1024}")
        done < <(ps -o pid,rss --no-headers -p $(IFS=','; echo "${all_pids[*]}") 2>/dev/null)
    fi
    
    # Now display all projects
    for name in "${project_names[@]}"; do
        IFS=':' read -r service_file working_dir <<< "${project_data[$name]}"
        
        local status="${service_status[$name]:-inactive}"
        local pid="${service_pids[$name]:--}"
        local memory="-"
        local uptime="-"
        
        if [[ "$status" == "active" ]]; then
            status="running"
            
            # Get memory from our cached data
            if [[ "$pid" != "-" ]]; then
                memory="${pid_memory[$pid]:--}"
            fi
            
            # Format uptime
            uptime=$(format_uptime "${service_uptimes[$name]}")
        else
            status="stopped"
        fi
        
        # Display with colors
        if [[ "$status" == "running" ]]; then
            echo -e "$(printf "%-20s " "$name")${GREEN}$(printf "%-10s" "$status")${NC}$(printf " %-8s %-10s %-12s %-30s" "$pid" "$memory" "$uptime" "$working_dir")"
        else
            echo -e "$(printf "%-20s " "$name")${RED}$(printf "%-10s" "$status")${NC}$(printf " %-8s %-10s %-12s %-30s" "$pid" "$memory" "$uptime" "$working_dir")"
        fi
    done
    echo
}

cmd_remove() {
    local name="$1"
    
    # If no name provided, try to infer from current directory
    if [[ -z "$name" ]]; then
        name=$(infer_project_name)
        if [[ $? -ne 0 || -z "$name" ]]; then
            log_error "No project name provided and no .service file found in current directory"
            log_info "Usage: sm remove <project_name> or run from directory containing .service file"
            exit 1
        fi
        log_info "Inferred project name: $name"
    fi
    
    if ! project_exists "$name"; then
        log_error "Project '$name' not found"
        exit 1
    fi
    
    read -p "Confirm to remove the project? (y/N): " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then

        log_info "Removing project '$name'..."

        # Stop and disable service
        sudo systemctl stop "$name.service" 2>/dev/null || true
        sudo systemctl disable "$name.service" 2>/dev/null || true

        # Remove service file
        sudo rm -f "/etc/systemd/system/$name.service"
        sudo systemctl daemon-reload

        # Remove from registry
        remove_from_registry "$name"

        log_success "Project '$name' removed successfully"
    fi
}


cmd_update() {
    local repo_dir
    repo_dir=$(find_sm_repo)
    
    if [[ -z "$repo_dir" ]]; then
        log_error "Could not find sm repository directory"
        exit 1
    fi
    
    if [[ ! -d "$repo_dir/.git" ]]; then
        log_error "sm repository directory is not a git repository: $repo_dir"
        log_info "The sm script should be in a git repository to use the update command"
        exit 1
    fi
    
    log_info "Updating sm from repository in: $repo_dir"
    
    # Change to repo directory and pull updates
    if (cd "$repo_dir" && git pull origin master); then
        log_success "sm updated successfully"
        log_info "Changes are immediately available since sm is symlinked"
    else
        log_error "Failed to update sm repository"
        exit 1
    fi
}

cmd_dive_dummy() {
    log_info "This command is not supposed to be run directly, looks like you haven't run 'sm install-helpers' yet."
    local name="$1"
    if [[ -z "$name" ]]; then
        log_info "To get the working directory, run 'sm workdir $name'"
    fi
}

cmd_install_helpers() {
    local repo_dir
    repo_dir=$(find_sm_repo)
    
    if [[ ! -f "$repo_dir/sm-completion.sh" ]]; then
        log_error "Completion script not found at: $repo_dir/sm-completion.sh"
        exit 1
    fi
    
    local bashrc="$HOME/.bashrc"
    local source_line="[[ -f \"$repo_dir/sm-completion.sh\" ]] && source \"$repo_dir/sm-completion.sh\""
    
    # Check if already installed
    if grep -qF "$repo_dir/sm-completion.sh" "$bashrc" 2>/dev/null; then
        log_info "Completion already installed in ~/.bashrc"
        log_info "Run 'source ~/.bashrc' to reload if needed"
    else
        echo "" >> "$bashrc"
        echo "# SM (Service Manager) helpful features" >> "$bashrc"
        echo "$source_line" >> "$bashrc"
        log_success "Completion installed to ~/.bashrc"
        log_info "Run 'source ~/.bashrc' or restart your terminal to activate"
    fi

    if [[ ! -f "$repo_dir/sm-wrapper-for-dive.sh" ]]; then
        log_error "Sm wrapper-for-dive not found at: $repo_dir/sm-wrapper-for-dive.sh"
        exit 1
    fi

    local source_line="[[ -f \"$repo_dir/sm-wrapper-for-dive.sh\" ]] && source \"$repo_dir/sm-wrapper-for-dive.sh\""

    # Check if already installed
    if grep -qF "$repo_dir/sm-wrapper-for-dive.sh" "$bashrc" 2>/dev/null; then
        log_info "Diving feature already installed in ~/.bashrc"
        log_info "Run 'source ~/.bashrc' to reload if needed"
    else
        echo "" >> "$bashrc"
        echo "$source_line" >> "$bashrc"
        log_success "Diving feature installed to ~/.bashrc"
        log_info "Run 'source ~/.bashrc' or restart your terminal to activate"
    fi
}

cmd_help() {
    echo "Service Manager (sm) - A lightweight wrapper around systemctl"
    echo
    echo "Usage:"
    echo "  sm add                        - Add project from current directory"
    echo "  sm start [project_name]       - Start a project (infers name from .service file if not provided)"
    echo "  sm stop [project_name]        - Stop a project (infers name from .service file if not provided)"
    echo "  sm logs [project_name]        - Show project logs (infers name from .service file if not provided)"
    echo "  sm remove [project_name]      - Remove a project (infers name from .service file if not provided)"
    echo "  sm workdir [project_name]     - Echo the project folder path"
    echo "  sm dive [project_name]        - Dive into a project folder (make sure to run 'sm install-helpers' first once)"
    echo "  sm ls                         - List all projects"
    echo "  sm update                     - Update sm from git repository"
    echo "  sm install-helpers            - Install tab completion and 'sm dive' working properly into your ~/.bashrc"
    echo "  sm help                       - Show this help message"
    echo
    echo "Note: Commands that accept [project_name] will automatically infer the project name"
    echo "      from .service files in the current directory if no name is provided."
    echo
}

# Main command dispatcher
main() {
    init_sm
    
    local command="$1"
    shift || true
    
    case "$command" in
        add)
            cmd_add "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        ls|list)
            cmd_ls "$@"
            ;;
        remove|rm)
            cmd_remove "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        workdir)
            cmd_workdir "$@"
            ;;
        install-helpers)
            cmd_install_helpers "$@"
            ;;
        dive)
            cmd_dive_dummy "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        "")
            log_error "No command specified. Use 'sm help' for usage information."
            exit 1
            ;;
        *)
            log_error "Unknown command: $command"
            cmd_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"